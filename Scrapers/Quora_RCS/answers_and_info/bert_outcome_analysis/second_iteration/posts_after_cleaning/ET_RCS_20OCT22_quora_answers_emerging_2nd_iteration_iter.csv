,Answer,followerCount,name,upvoteCount,answerCount,answerViews,question
0,"It depends.The difference between Flappy Birds and GTA5 is in the 100s of man-years. Possibly longer It makes it really tough to answer a super broad question.Games are a real-time simulation with user input. This is basically the most challenging space - you have massive constraints on performance, visual fidelity, responsiveness, intuitive controls and a bunch of other factors.It’s very easy to make a very poor game.It’s fairly easy to make a good but simple game. Pretty much anyone with a moderate amount of programming experience can knock out a quality guess a number or hangman/guess a worIt depends.The difference between Flappy Birds and GTA5 is in the 100s of man-years. Possibly longer It makes it really tough to answer a super broad question.Games are a real-time simulation with user input. This is basically the most challenging space - you have massive constraints on performance, visual fidelity, responsiveness, intuitive controls and a bunch of other factors.It’s very easy to make a very poor game.It’s fairly easy to make a good but simple game. Pretty much anyone with a moderate amount of programming experience can knock out a quality guess a number or hangman/guess a word or whatever game.When you start dialing up the standard for the game then the work gets harder. AAA games are hard. Individual tasks are generally hard - its a ton of unsolved problems being built on top of a foundation that few people have worked on and that was patched and duct taped together to ship a different game. Oh, and you have limited time to solve it because the market window is closing.Game development is generally not programmer oriented. That is, people aren’t getting together and talking about the code and then putting a game together with it. People have a visual concept or a player experience vignette and then they want a multidisciplinary team to execute on that. Organically. While the design changes. And make it fun. But not fun like that, fun like something else.",3 followers,Steve Baker,5.5K,27.3K,162.4M,https://www.quora.com/Is-game-programming-tough
1,"It used to be very, very difficult indeed when the hardware was weak, in the 1980s. Today it is much easier, because the hardware is handled by game engines such as Unity and Unreal. But it still can be challenging depending on the complexity of the game. A simple physics-based game is easy. One with a lot of AI is harder.",1 follower,Chris Nash,1.7K,5K,30.5M,https://www.quora.com/Is-game-programming-tough
2,"I’ve been a working programmer for close to 40 years - and video games are by far the hardest thing I’ve ever done. (And the most rewarding - both mentally and financially!)A modern, “AAA” video game title is likely to be one of the most complicated pieces of software written anywhere in the world.Grand Theft Auto V is claimed to contain over 100 million lines of code.The Linux Kernel is “only” 15 million lines.There is a claim that theI’ve been a working programmer for close to 40 years - and video games are by far the hardest thing I’ve ever done. (And the most rewarding - both mentally and financially!)A modern, “AAA” video game title is likely to be one of the most complicated pieces of software written anywhere in the world.Grand Theft Auto V is claimed to contain over 100 million lines of code.The Linux Kernel is “only” 15 million lines.There is a claim that theGTA-V is a SINGLE application.Furthermore - programs like GTA-V are written in C++ (which is probably the most complex programming language in existence) - and it was written over a relatively short period of time compared to the AT&T switching system.These games are complex in other ways too - the physics and graphics systems are truly insane in their degree of complexity and in the way that all of the sub-parts have to interact together. Just the simulation of sunlight in the GTA-V ‘world’ is an astoundingly complex thing.And that’s just the SOFTWARE complexity.Add in all of the crazy number of 3D models that have to be built, the number of sound effects, voice acting sessions, music!I read somewhere that getting all of the music used in the game licensed was so hard that there were more Intellectual Property lawyers employed in the making of the game than there were programmers!So I think it’s safe to say that video games are",1 follower,Chris Nash,13.6K,5K,30.5M,https://www.quora.com/Is-game-programming-tough
3,Physics. See:,"1,980 followers",Ira J Perlow,679,2.8K,4.5M,https://www.quora.com/Is-game-programming-tough
4,Space for the memory.Want to try squeezing 32 TB into one chip with the processor?Even 16GB won’t fit.,"220,192 followers",Franklin Veaux,976,47.3K,779.7M,https://www.quora.com/Is-game-programming-tough
5,Speed. The way in which memory speed slows with size has been explained in other answers so I’ll mention another issue.Multiprocessor shared memory systems.The fast operation of shared memory systems relies on that fact that at any time very few memory locations are actually shared between processors. The multiprocessor cache system provides a way of tracking ownership and typically or resolving ownership issues within a single processor. If all accesses had to be made to a genuinely shared memory system the sharing protocols would cause serious performance problems.,109 followers,Ameerul Aimar,888,79,379.3K,https://www.quora.com/Is-game-programming-tough
6,"This is a square:image from wikimediaWhy am I bringing up shapes, you ask? Well, squares have an interesting property: the Pythagorean theorem tells us that the diagonal of this square is equal to the square root of the squared sum of its side (a² = b² + c²). For a square of side 1, this means the diagonal has a length of √2.This scales: make the square bigger, you also make the diagonal longer. Double the length of the sides, you also double the length of the diagonal.Here’s another formula: d = v*t, and one of it’s reciprocals, t = d/v.Electricity travels at a finite speed within a wire: ifThis is a square:image from wikimediaWhy am I bringing up shapes, you ask? Well, squares have an interesting property: the Pythagorean theorem tells us that the diagonal of this square is equal to the square root of the squared sum of its side (a² = b² + c²). For a square of side 1, this means the diagonal has a length of √2.This scales: make the square bigger, you also make the diagonal longer. Double the length of the sides, you also double the length of the diagonal.Here’s another formula: d = v*t, and one of it’s reciprocals, t = d/v.Electricity travels at a finite speed within a wire: if you increase the amount of distance to travel, then the amount of time needed to do so will increase. Similarly, if you increase the size of your cache, it will take more time for you to reach the SRAM cells that are farther away.Of course, this is an oversimplification. Caches usually aren’t laid out in a perfect square, and are even broken into many separate banks. But the idea stays the same: if you increase your cache size, signals will need to travel farther on average to access it (seeing as some of these SRAM cells are now farther away from the core).If we look at it in practice:original unmodified image fromThose black lines (added by me) represent the maximum distance a signal would need to travel within the SRAM pool. Notice how much more distance these signals would need to cover if the cache size were to be doubled up.We can conclude: a cache’s small size contributes massively to its speed. Should you make it significantly larger, latency would increase substantially.This is why CPUs have multi-level caches by the way: the low-level caches can be fast, while the L3 can be slower but of larger capacity. This stems from the fact that is is simply not possible to make a cache that is both ultra-fast AND of high capacity.Let’s consider the case for memory too: if you were to replace your traditional CPU DRAM with SRAM, not only would the latency of this SRAM not be as low as in a CPU cache (due to its large size), it would be even worse than that given the fairly large distance signals would need to travel to reach this RAM in the first place (from the CPU to RAM). Physical proximity between the cache and RAM contributes to low latency as well.All and all, using SRAM as main RAM would not bring as much of a speedup as one might think. Given the increased cost of SRAM as well as its lower density vs DRAM, it’s simply not worth it. In the end, you’d sThere’s also power to consider. SRAM doesn’t have to be power hungry: given its asynchronous nature, it can actually be fairly low power. However, strap it to a CPU and make it run at multi-ghz speeds, and things start to get hot. SRAM starts burning a","9,554 followers",Glenn Luk,6.6K,427,7.9M,https://www.quora.com/What-are-some-reasons-other-than-cost-to-not-replace-RAM-entirely-with-a-cache-of-equal-size-If-cost-is-the-only-reason-we-would-ve-been-able-to-buy-very-expensive-but-super-fast-computers-right
7,"It is more a question of nomenclature than of what it actually is. Cache memory is, by definition in my opinion, a smaller but faster memory placed between main memory and the CPU. As well as the memory, cache has to include the cache comparison logic.The reason for cache is speed. It is faster to access on chip memory that it is off chip memory. If you can fit all the memory on chip, as many SoCs (System on Silicon) do, there is no need for cache, and those SoCs that don’t have external memory almost always don’t have caches either.But the amount of memory you can fit on one chip is limited.It is more a question of nomenclature than of what it actually is. Cache memory is, by definition in my opinion, a smaller but faster memory placed between main memory and the CPU. As well as the memory, cache has to include the cache comparison logic.The reason for cache is speed. It is faster to access on chip memory that it is off chip memory. If you can fit all the memory on chip, as many SoCs (System on Silicon) do, there is no need for cache, and those SoCs that don’t have external memory almost always don’t have caches either.But the amount of memory you can fit on one chip is limited. Furthermore, the silicon fabrication processes for extremely dense memories are different from those for CPUs and other irregular logic. So if you move memory on chip, it tends to get bigger at the same time as it gets faster.So there is a continually moving sweet spot in memory size below which caches are unnecessary. Unfortunately, software keeps on wanting more and more memory, so that sweet spot keeps moving either way.","3,120 followers",Becca Royal-Gordon,1.1K,4.3K,12M,https://www.quora.com/What-are-some-reasons-other-than-cost-to-not-replace-RAM-entirely-with-a-cache-of-equal-size-If-cost-is-the-only-reason-we-would-ve-been-able-to-buy-very-expensive-but-super-fast-computers-right
8,"Cray vector Computers through the cray C90, and prior to the X1 had no cache.The YMP 8/32 which is the first Cray that I programmed on was able to add two vectors from memory and store the result in memory from all 8 processors at a maximum of about 90% of processor speed. The cost was around $10 million in 1985, which did not include site preparation .","9,921 followers",Brett Bergan,1.3K,7K,82.9M,https://www.quora.com/What-are-some-reasons-other-than-cost-to-not-replace-RAM-entirely-with-a-cache-of-equal-size-If-cost-is-the-only-reason-we-would-ve-been-able-to-buy-very-expensive-but-super-fast-computers-right
9,"The rest of the answers gave a pretty representative sample of dynamic programming questions and you can always find more online (ex.Keep in mind that these are all great problems for learning dynamic programming, but they have nothing to do with the most popular ones in interviews. In fact,The rest of the answers gave a pretty representative sample of dynamic programming questions and you can always find more online (ex.Keep in mind that these are all great problems for learning dynamic programming, but they have nothing to do with the most popular ones in interviews. In fact,Typically when people ask about a popularity of something, they’re implying a power distribution where a few items are used disproportional number of times.Interview questions are distributed in a much more uniform distribution where there is not much point in talking about popularity.What you really want to ask is what are theHere is a list of the most important things to remember:Learn ideas, don’t learn problemsWhen you feel like you’ve conquered these ideas, check outEdit: I recently wrote up a","16,038 followers",Michal Danilák,5.6K,0,0,https://www.quora.com/Is-game-programming-tough
10,"Following questions are the most popular dynamic programming problems for interviews :Given a matrix consisting of 0's and 1's, find the maximum size sub-matrix consisting of only 1's.Following questions are the most popular dynamic programming problems for interviews :Given a matrix consisting of 0's and 1's, find the maximum size sub-matrix consisting of only 1's.",UNKNOWN,Anonymous,701,0,0,https://www.quora.com/Is-game-programming-tough
11,"Here is the list of 10 dynamic programming questions that are commonly asked by interviewers (I made this list while preparing for interviews):1. Dice Throw Problem: Given n dice each with m faces, numbered from 1 to m, find the number of  ways to get sum X. X is the summation of values on each face when all  the dice are thrown.Here is the list of 10 dynamic programming questions that are commonly asked by interviewers (I made this list while preparing for interviews):1. Dice Throw Problem: Given n dice each with m faces, numbered from 1 to m, find the number of  ways to get sum X. X is the summation of values on each face when all  the dice are thrown.5. Two-Person Traversal of a Sequence of Cities: You are given an ordered sequence of n cities, and the distances between every pair of cities. You must partition the cities into two subsequences (not necessarily contiguous) such that person A visits all cities in the first subsequence (in order), person B visits all cities in the second subsequence (in order), and such that the sum of the total distances travelled by A and B is minimized. Assume that person A and person B start initially at the first city in their respective subsequences.",36 followers,Richard Urwin,683,3.1K,13M,https://www.quora.com/Is-game-programming-tough
12,"Dynamic Programming Practice ProblemsDynamic Programming Archives - GeeksforGeeksThese links may help you. Most of the DP problems that I have faced in interviews are covered in these two sites.Topcoder also has a good collection of DP problems ranging from easy to hard. To gain confidence in DP I would suggest first go through the above links , then try solving the DP problems on Topcoder.","224,569 followers",Gayle Laakmann McDowell,1K,1.2K,49.7M,https://www.quora.com/What-are-some-reasons-other-than-cost-to-not-replace-RAM-entirely-with-a-cache-of-equal-size-If-cost-is-the-only-reason-we-would-ve-been-able-to-buy-very-expensive-but-super-fast-computers-right
13,"Dynamic programming is a very specific topic in programming competitions. No matter how many problems have you solved using DP, it can still surprise you. But as everything else in life, practice makes you better ;-)Other answers in this thread mention some nice introductory texts that will help you understand what DP is and how it works. In the following few paragraphs I will try to show you how to come up with solutions for DP problems.Note: the process of creating a DP solution, I describe below, is directly applicable for all the Div1-250 problems and many of Div1-500 problems on TopCoderDynamic programming is a very specific topic in programming competitions. No matter how many problems have you solved using DP, it can still surprise you. But as everything else in life, practice makes you better ;-)Other answers in this thread mention some nice introductory texts that will help you understand what DP is and how it works. In the following few paragraphs I will try to show you how to come up with solutions for DP problems.Note: the process of creating a DP solution, I describe below, is directly applicable for all the Div1-250 problems and many of Div1-500 problems on TopCoder which can be solved with DP. Harder problems usually requires some alternation in the process which you will be able to do, after some practice.Note 2: the source code samples below are written in C++. If you don't know the language or are unsure of something, please ask me in comments.Iteration vs. recursionAfter you read some introductory texts on dynamic programming (which I highly recommend), pretty much all the source code examples in them use bottom-up technique with iteration (i.e. using for-cycles). For example calculating the length of the longest common subsequence of two stringsint dp[N+1][N+1];There are couple of reasons why it is coded in this way:Looking at such source code, one can understand how and why it works, but it is much harder to understand how to come up with it.The biggest breakthrough in my learning of dynamic programming was, when I started to think about the problems in the top-down fashion, instead of bottom-up.On the first look it doesn't look as such a revolutionary insight, but these two approaches directly translates in two different source codes. One uses iteration (bottom-up fashion) and the other one uses recursion (top-down fashion). The latter one is also called the memoization technique. The two solutions are more or less equivalent and you can always transform one into the other.In the following paragraphs I will show you how to come up with a memoization solution for a problem.Motivation problemImagine you have a collection ofBecause the wines get better every year, supposing today is the year 1, on yearYou want to sell all the wines you have, but you want to sell exactly one wine per year, starting on this year. One more constraint - on each year you are allowed to sell only either the leftmost or the rightmost wine on the shelf and you are not allowed to reorder the wines on the shelf (i.e. they must stay in the same order as they are in the beginning).You want to find out, what is the maximum profit you can get, if you sell the wines in optimal order.So for example, if the prices of the wines are (in the order as they are placed on the shelf, from left to right):Wrong solutionAfter playing with the problem for a while, you'll probably get the feeling, that in the optimal solution you want to sell the expensive wines as late as possible. You can probably come up with the following greedy strategy:Every year, sell the cheaper of the two (leftmost and rightmost) available wines.Every year, sell the cheaper of the two (leftmost and rightmost) available wines.Although the strategy doesn't mention what to do when the two wines cost the same, this strategy kinda feels right. But unfortunately, it isn't, as the following example demonstrates. If the prices of the wines are:The greedy strategy would sell them in the orderBut we can do better if we sell the wines in the orderThis counter-example should convince you, that the problem is not so easy as it can look on a first sight and I will tell you, that it can be solved using DP.Write a backtrackWhen coming up with the memoization solution for a problem, I always start with a backtrack solution that finds the correct answer. Backtrack solution enumerates all the valid answers for the problem and chooses the best one. For most of the problems it is easy to come up with such solution.Here are some restrictions I put on a backtrack solution:So for the problem with wines, the backtrack solution will look like this:int p[N]; // read-only array of wine pricesWe can get the answer by calling:int answer = profit(1, 0, N-1); // N is the total number of winesThis solution simply tries all the possible valid orders of selling the wines. If there areThe correctly written backtrack function should always represent an answer to a well-stated question. In our caseMinimize the state space of function argumentsIn this step I want you to think about, which of the arguments you pass to the function are redundant. Either we can construct them from the other arguments or we don't need them at all. If there are any such arguments, don't pass them to the function. Just calculate them inside the function.In the above functionint N; // read-only number of wines in the beginningI also want you to think about the range of possible values the function arguments can get from a valid input. In our case, each of the argumentsNow cache itWe are now 99% done. To transform the backtrack function with time complexity O(2^As noted above, there are only O(The answer is - the exponential time complexity comes from the repeated recursion and because of that, it computes the same values again and again. If you run the above code for an arbitrary array ofint N; // read-only number of wines in the beginningAnd that's it! With that little trick it runs O(Note: when the values are cached, you can treat every recursive call inside the function as it would run in O(1) time complexity.SummaryTo sum it up, if you identify that a problem can be solved using DP, try to create a backtrack function that calculates the correct answer. Try to avoid the redundant arguments, minimize the range of possible values of function arguments and also try to optimize the time complexity of one function call (remember, you can treat recursive calls as they would run in O(1) time). Finally cache the values and don't calculate the same things twice.The final time complexity of the solution is:",817 followers,Sumeet Raj Thakker,32.1K,0,0,https://www.quora.com/What-are-some-reasons-other-than-cost-to-not-replace-RAM-entirely-with-a-cache-of-equal-size-If-cost-is-the-only-reason-we-would-ve-been-able-to-buy-very-expensive-but-super-fast-computers-right
14,"Firstly, let me put forth my own thought process for solving DP problems (since its short), and then refer you to other sources.NOTE: All DPs can be (re)formulated as recursion. The extra effort you put in in finding out what is the underlying recursion will go a long way in helping you in future DP problems.STEP1:Firstly, let me put forth my own thought process for solving DP problems (since its short), and then refer you to other sources.NOTE: All DPs can be (re)formulated as recursion. The extra effort you put in in finding out what is the underlying recursion will go a long way in helping you in future DP problems.STEP1:In the above, theTrust me: I've solved loads of TC problems on DP just using the above methodology. It took me about max 2 months to imbibe this methodology, so unlike everyone's ""Keep practicing"" advice (which I would liken toBtw, if you can identify me by my advice, good for you. The point of going anonymous is mainly so that people don'tNow for some examples:Now for some examples:Q.The above particular example was demonstrated to me by a friend and prior to his demonstration (of how easy DP is), I was completely baffled by DPs myself.Q.Q.Now, enough of examples (answer is becoming too long). If you have any DP question you'd like me to work my magic on, post it as a comment :)Now, enough of examples (answer is becoming too long). If you have any DP question you'd like me to work my magic on, post it as a comment :)Please have a look at Mimino's answers on DP:","4,497 followers",William Pietri,7.9K,554,5.1M,https://www.quora.com/What-are-some-reasons-other-than-cost-to-not-replace-RAM-entirely-with-a-cache-of-equal-size-If-cost-is-the-only-reason-we-would-ve-been-able-to-buy-very-expensive-but-super-fast-computers-right
15,"Hours?My toughest bug took nearly six man-months to find.I’ve talked about this one a few times on here.The program would run for an hour or maybe three and would then crash due to memory corruption. I worked on it for months. I instrumented all memory allocations, every function, everything I could think of. If I got close then the symptoms would change. I found a lot of bugs, fixed them, thought it was working, left it overnight and it found it crashed the next morning. Because it took so long to fail, I could only really test it one time per day.In the end there were three expert programmerHours?My toughest bug took nearly six man-months to find.I’ve talked about this one a few times on here.The program would run for an hour or maybe three and would then crash due to memory corruption. I worked on it for months. I instrumented all memory allocations, every function, everything I could think of. If I got close then the symptoms would change. I found a lot of bugs, fixed them, thought it was working, left it overnight and it found it crashed the next morning. Because it took so long to fail, I could only really test it one time per day.In the end there were three expert programmers searching for that bug.Eventually one of the others found it with a line-by-line painstaking static analysis. I then confirmed it and found the correct fix in two days.The fix was changing a zero to “16384”. Any number over around 6000 would have worked.",20 followers,Amit Singh,24.9K,0,0,https://www.quora.com/What-are-some-reasons-other-than-cost-to-not-replace-RAM-entirely-with-a-cache-of-equal-size-If-cost-is-the-only-reason-we-would-ve-been-able-to-buy-very-expensive-but-super-fast-computers-right
16,"I'll probably annoy some algorithms people by saying this, but, dynamic programming is little more than recursion that uses a hash table. It's not this big scary concept. Fibonacci, if implemented recursively (and efficiently), uses dynamic programming. So that's the first thing to realize:Are they important for Google interviews? Yes and no. Google interviewers (like interviewers at ANY top tech company -- Google is not particularly differenI'll probably annoy some algorithms people by saying this, but, dynamic programming is little more than recursion that uses a hash table. It's not this big scary concept. Fibonacci, if implemented recursively (and efficiently), uses dynamic programming. So that's the first thing to realize:Are they important for Google interviews? Yes and no. Google interviewers (like interviewers at ANY top tech company -- Google is not particularly different) want to ask you questions that will challenge you so that they can assess your intelligence and coding skills. It's possible that some of those will be dynamic programming. (That said, as a member of Google hiring committee, I don't recall hearing many interviewers talk about asking dynamic programming questions.)Google does not tell its interviewers what to ask. There is no system that's like ""okay, now, Bob should ask about trees and Christy should ask about scalability."" It's just... Bob asks whatever he wants. Christy asks whatever she wants. Maybe they'll both happen to ask questions that involve trees. So what?What I tell candidates is this:Want to know if a particular topic is likely to be asked at Google? CareerCup's got about ~500 questions (",76 followers,Carlos Portocarrero,3.3K,0,0,https://www.quora.com/What-are-some-reasons-other-than-cost-to-not-replace-RAM-entirely-with-a-cache-of-equal-size-If-cost-is-the-only-reason-we-would-ve-been-able-to-buy-very-expensive-but-super-fast-computers-right
